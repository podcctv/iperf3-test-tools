"""
IP Whitelist Management Module for Agent

Manages allowed IP addresses for iperf3 test requests.
Only IPs in the whitelist can execute tests through this agent.
"""

import os
import logging
from typing import List, Set
from pathlib import Path
from threading import Lock

logger = logging.getLogger(__name__)

class IPWhitelist:
    """Thread-safe IP whitelist manager"""
    
    def __init__(self, whitelist_file: str = "/app/data/ip_whitelist.txt"):
        self.whitelist_file = Path(whitelist_file)
        self._allowed_ips: Set[str] = set()
        self._lock = Lock()
        
        # Ensure data directory exists
        self.whitelist_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Load whitelist from file or environment
        self.reload()
    
    def reload(self) -> None:
        """Reload whitelist from file and environment variable"""
        with self._lock:
            self._allowed_ips.clear()
            
            # Load from environment variable (comma-separated)
            env_ips = os.getenv("ALLOWED_IPS", "")
            if env_ips:
                for ip in env_ips.split(","):
                    ip = ip.strip()
                    if ip:
                        self._allowed_ips.add(ip)
                logger.info(f"Loaded {len(self._allowed_ips)} IPs from environment")
            
            # Load from file (one IP per line)
            if self.whitelist_file.exists():
                try:
                    with open(self.whitelist_file, 'r') as f:
                        for line in f:
                            ip = line.strip()
                            if ip and not ip.startswith('#'):
                                self._allowed_ips.add(ip)
                    logger.info(f"Loaded {len(self._allowed_ips)} IPs from {self.whitelist_file}")
                except Exception as e:
                    logger.error(f"Failed to load whitelist from file: {e}")
            
            # Always allow localhost
            self._allowed_ips.add("127.0.0.1")
            self._allowed_ips.add("::1")
            
            logger.info(f"Total allowed IPs: {len(self._allowed_ips)}")
    
    def update(self, ips: List[str]) -> None:
        """Update whitelist with new IP list"""
        with self._lock:
            self._allowed_ips.clear()
            
            # Add new IPs with validation
            for ip in ips:
                ip = ip.strip()
                if ip and self._is_valid_ip(ip):
                    self._allowed_ips.add(ip)
                elif ip:
                    logger.warning(f"Skipping invalid IP address: {ip}")
            
            # Always allow localhost
            self._allowed_ips.add("127.0.0.1")
            self._allowed_ips.add("::1")
            
            # Save to file
            try:
                with open(self.whitelist_file, 'w') as f:
                    f.write("# IP Whitelist - Auto-generated by Master\n")
                    f.write("# Do not edit manually\n\n")
                    for ip in sorted(self._allowed_ips):
                        if ip not in ["127.0.0.1", "::1"]:  # Don't write localhost
                            f.write(f"{ip}\n")
                logger.info(f"Updated whitelist with {len(self._allowed_ips)} IPs")
            except Exception as e:
                logger.error(f"Failed to save whitelist to file: {e}")
    
    def _is_valid_ip(self, ip: str) -> bool:
        """Validate IP address format (supports both IPv4 and IPv6)"""
        import ipaddress
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            # Check if it's a CIDR notation
            try:
                ipaddress.ip_network(ip, strict=False)
                return True
            except ValueError:
                return False
    
    def is_allowed(self, ip: str) -> bool:
        """Check if an IP is in the whitelist (supports CIDR matching)"""
        import ipaddress
        
        with self._lock:
            # Direct match
            if ip in self._allowed_ips:
                return True
            
            # Check CIDR ranges
            try:
                ip_obj = ipaddress.ip_address(ip)
                for allowed in self._allowed_ips:
                    try:
                        # Check if it's a network (CIDR)
                        network = ipaddress.ip_network(allowed, strict=False)
                        if ip_obj in network:
                            return True
                    except ValueError:
                        # Not a network, skip
                        continue
            except ValueError:
                # Invalid IP format
                logger.warning(f"Invalid IP address format: {ip}")
                return False
            
            return False
    
    def get_all(self) -> List[str]:
        """Get all allowed IPs"""
        with self._lock:
            return sorted(list(self._allowed_ips))
    
    def add(self, ip: str) -> None:
        """Add a single IP to whitelist"""
        with self._lock:
            self._allowed_ips.add(ip.strip())
            logger.info(f"Added IP to whitelist: {ip}")
    
    def remove(self, ip: str) -> None:
        """Remove a single IP from whitelist"""
        with self._lock:
            self._allowed_ips.discard(ip.strip())
            logger.info(f"Removed IP from whitelist: {ip}")


# Global whitelist instance
whitelist = IPWhitelist()
